## 선택 정렬
- 가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복
- 시간복잡도: O(N^2)

## 삽입 정렬
- 삽입 정렬은 2번째 데이터부터 시작.
- 삽입될 위치를 찾기 위해 왼쪽으로 한 칸씩 이동하다가, 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추고 삽입된다.
- 시간복잡도: O(N^2) 단, 데이터가 거의 정렬되어 있는 상태라면 빨라짐. 최선의 경우 O(N)

## 퀵정렬
- 기준 데이터(피벗)를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다
- 왼쪽에서 찾는 값과 오른 쪽에서 찾는 겂의 위치가 엇갈리면, 작은 데이터와 피벗의 위치를 변경한다.
- 피벗을 기준으로 왼쪽과 오른쪽을 분할하고 각각 파티션에서 동일하게 실시한다.
시간복잡도: O(NlogN)
정렬되어 있는 경우에는 매우 느리게 동작.

# 계수정렬
- 리스트의 인덱스가 모든 범위를 포함할 수 있또록 별도의 리스트를 선언하고, 그 안에 정렬에 대한 정보를 담는다.
- 데이터가 0과 999,999 단 2개만 존재해도 리스트의 크기가 100만개가 되도록 선언해야 함.
- 따라서, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합.
시간복잡도: O(N + K)
공간복잡도: O(N + K)

# 기본 정렬 라이브러리 sorted()
- 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어짐.
- 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장함.